package main

import (
	"bufio"
	"bytes"
	"encoding/csv"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"time"
)

func splitCSV(file2split *string, splitinto int, columns int) {
	startTime := time.Now()
	log.Print("\n#### File Split ####\n")
	//Adding +1 in case of round down
	columnsperfile := (int)(columns/splitinto) + 1
	log.Printf("Will print a max of %d columns per file", columnsperfile)
	iterator := 0
	for i := 0; i < splitinto; i++ {
		//Opening input file
		inputFileSplit, err := os.Open(*file2split)
		if err != nil {
			log.Fatal(err)
		}
		defer inputFileSplit.Close()

		//Create reader
		reader := csv.NewReader(inputFileSplit)

		//Create output file
		newfilename := string("split" + strconv.Itoa(i) + *file2split)
		log.Println("Creating file:", newfilename)
		outputFileSplit, err := os.Create(newfilename)
		if err != nil {
			log.Fatal(err)
		}
		defer outputFileSplit.Close()
		csvwriter := csv.NewWriter(outputFileSplit)

		for {
			record, err := reader.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatal(err)
			}
			stringChain := make([]string, 1)
			stringChain[0] = record[0]
			max := len(record)
			for i := iterator * columnsperfile; i < ((iterator+1)*columnsperfile) && (i < (max - 1)); i++ {
				stringChain = append(stringChain, record[i+1])
			}
			csvwriter.Write(stringChain)
			csvwriter.Flush()
		}
		inputFileSplit.Close()
		outputFileSplit.Close()
		iterator++
	}
	elapsed := time.Since(startTime)
	log.Printf("Time used to split files was %s", elapsed)

	return
}

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func main() {
	start := time.Now()
	//Try to get the file to be used from the args
	fptr := flag.String("i", "input.csv", "File path to read from")
	fptr2 := flag.String("o", "output.csv", "File path to write to")
	hostname := flag.String("h", "localhost", "String to remove from header ie: '-s localhost' will remove \\\\localhost\\")
	splitint := flag.Int("s", 1, "Number of csv files to create. Same number of rows, a fraction of the columns")
	flag.Parse()

	if *splitint <= 0 {
		*splitint = 1
	}

	log.Println("Analyzing", *fptr)
	log.Println("Writing to", *fptr2)
	log.Println("Removing string \\\\" + *hostname + "\\")
	log.Println("Splitting CSV into", *splitint)

	//Opening input file
	inputFile, err := os.Open(*fptr)
	if err != nil {
		log.Fatal(err)
	}
	defer inputFile.Close()

	//Create reader
	reader := bufio.NewReader(inputFile)

	//Creating output file
	outputFile, err := os.Create(*fptr2)
	if err != nil {
		log.Fatal(err)
	}
	defer outputFile.Close()

	//Create writer
	writer := bufio.NewWriter(outputFile)

	//Clean up headers
	var buffer bytes.Buffer
	var l []byte
	var isPrefix bool
	for {
		l, isPrefix, err = reader.ReadLine()
		buffer.Write(l)

		// If we've reached the end of the line, stop reading.
		if !isPrefix {
			break
		}
	}
	line := buffer.String()
	//Converting line read to array so it can be indexed
	array := []rune(line)
	//Replacing tail ',' with a '\n'
	array[len(array)-1] = '\n'

	//Remove all \\localhost\ from the headers
	header := strings.ReplaceAll(string(array), "\\\\"+*hostname+"\\", "")

	//Count the number of columns on the header
	columns := strings.Count(header, ",") + 1
	log.Printf("The file has %d columns", columns)

	//Removing all the '\' characters, replacing them with a '-'
	//Grafana autogenerated queries to InfluxDB have a problem with the '\' character
	header2 := strings.ReplaceAll(header, "\\", "-")

	// Write header
	writesize, err := writer.WriteString(string(header2))
	check(err)

	log.Printf("Processed Header %d \n", writesize)

	var i = 1
	//Parsing the csv file
	for {
		var CSVbuffer bytes.Buffer
		var CSVl []byte
		var CSVisPrefix bool

		//Cycle through the lines
		for {
			CSVl, CSVisPrefix, err = reader.ReadLine()
			CSVbuffer.Write(CSVl)

			if err != nil {
				if err != io.EOF {
					fmt.Printf("Didn't get to EOF\n")
					return
				}
				log.Printf("EOF reached\n")
				writer.Flush()
				elapsed := time.Since(start)
				log.Printf("Processed %d lines", i)
				log.Printf("Time used to process was %s", elapsed)
				err := outputFile.Close()
				if err != nil {
					log.Fatal(err)
				}
				if *splitint > 1 {
					splitCSV(fptr2, *splitint, columns)
				}
				return
			}
			// If we've reached the end of the line, stop reading.
			if !CSVisPrefix {
				break
			}
		}
		CSVline := CSVbuffer.String()
		//Converting line read to array so it can be indexed
		CSVarray := []rune(CSVline)
		//Replacing tail ',' with a '\n'
		CSVarray[len(CSVarray)-1] = '\n'
		//Swapping arround day and month ie "08/31 to "31/08"
		CSVarray[1], CSVarray[2], CSVarray[4], CSVarray[5] = CSVarray[4], CSVarray[5], CSVarray[1], CSVarray[2]
		//Removing all the '"' characters, replacing them with a ''
		//InfluxDB would import as a string
		CSVdata := strings.ReplaceAll(string(CSVarray), "\"", "")

		// Process the line here.
		/*writesize, err := */
		writer.WriteString(CSVdata)
		check(err)
		i++
		/*
			if len(CSVdata) == writesize {
				fmt.Printf("Line %d - ", i)
				i++
				fmt.Printf("Read %d characters ", len(CSVline))
				fmt.Printf("Wrote a full line of %d characters\n", writesize)
			}
		*/

	}
}
